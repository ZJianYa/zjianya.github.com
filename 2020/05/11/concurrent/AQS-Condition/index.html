<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>AQS &amp; ReentrantLock &amp; Condtion 源码解读 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="先说一下我解读的是 JDK1.8 源码.如果你没有 30 分钟的时间来看这篇文章, 就不要继续往下看了, 因为阅读顺利的情况下, 我估计也在20分钟左右, 更何况笔者表达能力堪忧;如果对链表这些基础知识都不熟, 也不要继续往下看这篇文章了, 否则, 这篇文章只会增加你的困惑, 更不要说本人表述能力差, 写的文章大多只能自己看懂.对于初学者（Java) 而言, 越多过程中可能还是会遇到一系列问题,">
<meta property="og:type" content="article">
<meta property="og:title" content="AQS &amp; ReentrantLock &amp; Condtion 源码解读">
<meta property="og:url" content="http://yoursite.com/2020/05/11/concurrent/AQS-Condition/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="先说一下我解读的是 JDK1.8 源码.如果你没有 30 分钟的时间来看这篇文章, 就不要继续往下看了, 因为阅读顺利的情况下, 我估计也在20分钟左右, 更何况笔者表达能力堪忧;如果对链表这些基础知识都不熟, 也不要继续往下看这篇文章了, 否则, 这篇文章只会增加你的困惑, 更不要说本人表述能力差, 写的文章大多只能自己看懂.对于初学者（Java) 而言, 越多过程中可能还是会遇到一系列问题,">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-05-10T16:00:00.000Z">
<meta property="article:modified_time" content="2020-05-11T11:59:47.524Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Java 并发">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-concurrent/AQS-Condition" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/11/concurrent/AQS-Condition/" class="article-date">
  <time datetime="2020-05-10T16:00:00.000Z" itemprop="datePublished">2020-05-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      AQS &amp; ReentrantLock &amp; Condtion 源码解读
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>先说一下我解读的是 JDK1.8 源码.<br>如果你没有 30 分钟的时间来看这篇文章, 就不要继续往下看了, 因为阅读顺利的情况下, 我估计也在20分钟左右, 更何况笔者表达能力堪忧;<br>如果对链表这些基础知识都不熟, 也不要继续往下看这篇文章了, 否则, 这篇文章只会增加你的困惑, 更不要说本人表述能力差, 写的文章大多只能自己看懂.<br>对于初学者（Java) 而言, 越多过程中可能还是会遇到一系列问题, 比如不了解 happen-before 原则, 可能还需要查阅其他资料…<br>这里还要提醒的一点是, 即便是看 JDK 的源码也要懂一些设计模式和面向对象编程思想(通常认为后者包含前者), 否则会有时候看不懂其中的”编码套路”.  </p>
<h2 id="需求和概述"><a href="#需求和概述" class="headerlink" title="需求和概述"></a>需求和概述</h2><p>众所周知, Java 主要提供了两种对线程加锁和通信的方法：</p>
<ul>
<li>Synchronized 关键字加锁<br>synchronized 原理涉及了偏斜锁、自旋锁、轻量级锁、重量级锁、锁的膨胀、降级等概念。  </li>
<li>使用 Lock 相关的API, 手动编程式的加锁<br>Lock 利用了 happen-before 规则和 unsafe 类的 CAS 方法, 保证了锁的(状态 state)操作是线程安全, 借助于 state 来保证临界区的互斥和同步。<br>通过 unsafe 提供的 park 方法来实现等待，通过 unpark 来实现唤醒。<br>其实从本质上讲 synchronized 关键字和 Lock 加锁的思路是一样.   </li>
<li>两者的关系?<br>Synchronized 关键字相当于提供了语法糖, 使得线程安全变得相对容易.<br>而编程式的加锁方式, (相对于声明式和配置式的编程)和所有编程式的解决方案一样是为了提供更灵活的方式和应对更加复杂的场景(隐含的意思是未必是性能最佳的).<br>实际上 Lock API 不仅可以用于保护临界资源, 还可以用来实现信号量等锁的变体.  </li>
</ul>
<p>从使用层面讲, 使用锁大体上要执行这样 4 步操作:  </p>
<ul>
<li>我们需要用 Lock 接口定义的 lock() 方法来保护临界资源的访问<br>可能会使用条件变量来进行线程间的通信(比如是生产/消费模式), 当然也可能不需要进行通信(比如仅仅简单的争抢)  <ul>
<li>然后可能需要判断是否满足程序的执行条件(比如库存是否够消费),<br>如果不够则通过 Condition 接口定义的 wait() 方法退出临界区，</li>
<li>一旦执行完毕则可能需要通过 Condition 接口定义的 signalAll() 方法来唤醒等待的线程。</li>
</ul>
</li>
<li>最后还需要通过 Lock 接口定义的 release() 方法释放锁.</li>
</ul>
<h2 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h2><p>我们在 JUC 解读中讲到, JUC 中的锁设计上的思路大体如下:  </p>
<ul>
<li>Lock 接口负责定义加锁的和解锁的逻辑, Condition 负责线程间通信的逻辑<br>所有的 Lock 和 Condition 只是定义了操作接口<br>大部分 Lock 的实现类内部要用到 AbstractQueuedSynchronizer 的具体子类 Sync, 比如: ReentrantReadWriteLock, ReentrantLock; 当然也有例外, 比如 StampedLock<br>AbstractQueuedSynchronizer 本身是 Sync 的父类, 并包含了 ConditionObject , AbstractQueuedSynchronizer 才是核心。<br>这里的 Lock 的实现类和 AbstractQueuedSynchronizer 的关系在我看来就是门面模式中的高层接口和子系统关系, 没错我认为这里使用了门面模式.<br>门面模式对使用者是友好的, 但是对维护者或者看源码的人来说增加了一点困惑, 有时候会不太容易理解这样设计的原因和好处.  </li>
<li>AbstractQueuedSynchronizer(以下简称为 AQS)<br>AQS 是一个 FIFO 的双向队列, 通过队列来记录已经获得锁和等待锁的线程(这背后其实是参考的 CLH 算法).<br>根本上的实现思路其实和 synchronized 的方式是完全一样, 都是通过一个变量来判断是否获取了锁, 在这里这个变量是内部成员变量 state.<br>AQS 只是定义了如何操作队列, 本身并未实现具体加锁解锁逻辑, 而是由子类完成.<br>因为公平锁、非公平锁的加锁逻辑会有所不同, 具体内容会在本文中详细展开.    </li>
<li>Condition<br>Condition 要负责线程间的通信, 一定会和 Sync 打交道, 所以会定义在 AQS 内部, 也会在本文中详细说明.  </li>
</ul>
<h2 id="AQS-主要属性和方法解释"><a href="#AQS-主要属性和方法解释" class="headerlink" title="AQS 主要属性和方法解释"></a>AQS 主要属性和方法解释</h2><p>AQS 是一个 FIFO 的双向队列，其内部通过节点 head 和 tail 记录队首和队尾元素，队列元素的类型为 Node.<br>记住 AQS 是一个队列, 这一点是非常重要的, 而且它本身就是只实现了队列的相关操作, 而实际的加锁部分都交给了子类去实现, 这是 Doug Lea 高明的地方, 也是容易困惑的地方(当然对于高手来讲很少会有困惑, 反正我过去看别人博客的时候, 经常被人带坑里, 他们也不懂这背后的原因).  </p>
<ul>
<li>state The synchronization state, 我会简单理解为当前锁的状态, 当然在其子类中含义会各不相同.<br>可以通过 getState, setState, compareAndSetState 函数获取和修改其值。  <ul>
<li>对于 ReentrantLock 的实现来说, state 可以用来表示当前线程获取锁的可重入次数  </li>
<li>对于 ReentrantReadWriteLock 的实现来说, state 的高16位表示读状态，也就是获取该读锁的次数，低16位表示获取到写锁的线程的可重入次数  </li>
<li>对于 Semaphore 来说，state 用来表示当前可用信号的个数</li>
<li>对于 CountDownlatch 来说，state 用来表示计数器当前的值</li>
</ul>
</li>
<li>Node  <ul>
<li>SHARED 用来标记该线程是获取共享资源时被阻塞挂起后放入AQS队列的，</li>
<li>EXCLUSIVE 用来标记线程是获取独占资源时被挂起后放入AQS队列的</li>
<li>waitStatus 记录当前线程等待状态，可以为CANCELLED（线程被取消了）、SIGNAL（线程需要被唤醒）、CONDITION（线程在条件队列里面等待）、PROPAGATE（释放共享资源时需要通知其他节点）; prev记录当前节点的前驱节点，next记录当前节点的后继节点。  </li>
<li>prev 记录当前节点的前驱节点，next 记录当前节点的后继节点。  </li>
</ul>
</li>
<li>ConditionObject, 用来结合锁实现线程同步。<br>ConditionObject 可以直接访问AQS对象内部的变量，比如state状态值和AQS队列。<br>ConditionObject 是条件变量，每个条件变量(也就是每个 ConditionObject 的实例都会)都会维护一个队列（单向链表队列），其用来存放调用ConditionObject.await() 方法后被阻塞的线程，这个条件队列的头、尾元素分别为 firstWaiter 和 lastWaiter。  </li>
<li>加锁和解锁逻辑<br>实际上 AQS 并没有做任何实现获取锁和释放锁的逻辑, 而是交给了子类去做, 因为子类要用这个队列来实现共享锁还是独占锁, 公平锁还是非公平锁是不确定的.<br>但是 AQS 实现了获取锁失败的处理逻辑: <code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</code><br>AQS 实现了解锁成功之后的处理逻辑: <code>Node h = head; if (h != null &amp;&amp; h.waitStatus != 0)  unparkSuccessor(h);</code>  <ul>
<li>独占方式下获取和释放资源使用的方法为：<br>使用独占方式获取的资源是与具体线程绑定的，就是说如果一个线程获取到了资源，就会标记是这个线程获取到了，其他线程再尝试操作state获取资源时会发现当前该资源不是自己持有的，就会在获取失败后被阻塞。  <ul>
<li>void acquire(int arg) 内部通过 setExclusiveOwnerThread(current); 方法标记是这个线程获取到了资源(即获得了锁).  </li>
<li>void acquireInterruptibly(int arg)</li>
<li>boolean release(int arg)</li>
</ul>
</li>
<li>共享方式下获取和释放资源的方法为： <ul>
<li>void acquireShared(int arg)  </li>
<li>void acquireSharedInterruptibly(int arg)  </li>
<li>boolean releaseShared(int arg)  </li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="AQS-具体实现类"><a href="#AQS-具体实现类" class="headerlink" title="AQS 具体实现类"></a>AQS 具体实现类</h2><p>因为 AQS 并没有做任何实现获取锁和释放锁的逻辑, 而是交给了子类去做, 它只是实现了对队列的操作.<br>所以我们没打算直接在 AQS 中讲太多内容, 转而在他的实现类(子类中)做详细阐述, 我们希望能够一次性讲得完整些.  </p>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>我们先说一下整体思路, 在这里 AQS 的 state 状态值表示线程获取该锁的可重入次数:<br>在默认情况下，state 的值为 0 表示当前锁没有被任何线程持有。<br>当一个线程第一次获取该锁时会尝试使用 CAS 设置 state 的值为 1，如果CAS成功则当前线程获取了该锁，然后记录该锁的持有者为当前线程。<br>在该线程没有释放锁的情况下第二次获取该锁后，状态值被设置为 2，这就是重入次数。<br>在该线程释放该锁时，会尝试使用CAS让状态值减1，如果减1后状态值为0，则当前线程释放该锁。</p>
<h4 id="非公平锁模式"><a href="#非公平锁模式" class="headerlink" title="非公平锁模式"></a>非公平锁模式</h4><h5 id="lock-方法解读"><a href="#lock-方法解读" class="headerlink" title="lock 方法解读"></a>lock 方法解读</h5><p>这里不会做更多的解释, 简单的列一下调用栈(更多信息看代码以及注释):  </p>
<ul>
<li>java.util.concurrent.locks.ReentrantLock.NonfairSync.lock()<ul>
<li>首先调用的是 AQS 的方法,尝试获取锁<br>java.util.concurrent.locks.AbstractQueuedSynchronizer.compareAndSetState() </li>
<li>失败之后,调用 acquire 的方法再次尝试获取锁, 这里实际上要调用子类的实现方法了<br>java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(int arg)  <ul>
<li>java.util.concurrent.locks.ReentrantLock.NonfairSync.tryAcquire(int)<br>获取成功的话就短路终止了, 否则会继续调用 acquireQueued 方法  <ul>
<li>java.util.concurrent.locks.ReentrantLock.NonfairSync.nonfairTryAcquire(int acquires)</li>
</ul>
</li>
<li>java.util.concurrent.locks.AbstractQueuedSynchronizer.addWaiter(Node)<br>获取锁失败就添加到队列中去, 并且  <blockquote>
<p>我觉得 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) 这个写法本来没什么问题, 但是在这里会增加很大的迷惑性<br>实际上写成 Node node = addWaiter(…); acquireQueued( node, arg) 就会清晰很多, 当然这样一来<br>if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>的格式就要完全重写一下  </p>
</blockquote>
</li>
<li>java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(final Node node, int arg)<br>for(){ … tryAcquire(arg) … } 继续通过自旋的方式试图获得锁<br>parkAndCheckInterrupt() 暂停当前线程</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.locks.ReentrantLock.NonfairSync.lock() &#123;</span><br><span class="line">    &#x2F;&#x2F; 直接尝试获取锁, 调用的是 AQS 的方法</span><br><span class="line">    if (compareAndSetState(0, 1))</span><br><span class="line">        &#x2F;&#x2F; 把当前线程设置为获取了锁的线程</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    else</span><br><span class="line">        &#x2F;&#x2F; 调用获取锁的方法, 这里实际上要调用 AQS 子类的实现方法了</span><br><span class="line">        acquire(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 修改 state 状态</span><br><span class="line">java.util.concurrent.locks.AbstractQueuedSynchronizer.compareAndSetState(int expect, int update) &#123;</span><br><span class="line">    &#x2F;&#x2F; See below for intrinsics setup to support this</span><br><span class="line">    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注意阅读以下地方  </span><br><span class="line">java.util.concurrent.locks.AbstractQueuedSynchronizer  </span><br><span class="line">static &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        stateOffset &#x3D; unsafe.objectFieldOffset</span><br><span class="line">            (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;state&quot;));</span><br><span class="line">        headOffset &#x3D; unsafe.objectFieldOffset</span><br><span class="line">            (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;head&quot;));</span><br><span class="line">        tailOffset &#x3D; unsafe.objectFieldOffset</span><br><span class="line">            (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;tail&quot;));</span><br><span class="line">        waitStatusOffset &#x3D; unsafe.objectFieldOffset</span><br><span class="line">            (Node.class.getDeclaredField(&quot;waitStatus&quot;));</span><br><span class="line">        nextOffset &#x3D; unsafe.objectFieldOffset</span><br><span class="line">            (Node.class.getDeclaredField(&quot;next&quot;));</span><br><span class="line"></span><br><span class="line">    &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取锁的逻辑, 如果失败则存入 AQS 的队列, 然后再判断如果前驱节点已经是 head 节点则自旋, 如果不是则 park 自己</span><br><span class="line">java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">java.util.concurrent.locks.ReentrantLock.NonfairSync.tryAcquire(int) &#123;</span><br><span class="line">    return nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">java.util.concurrent.locks.ReentrantLock.NonfairSync.nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">    &#x2F;&#x2F; 获得当前线程对象</span><br><span class="line">    final Thread current &#x3D; Thread.currentThread();</span><br><span class="line">    &#x2F;&#x2F; 查询当前锁的状态</span><br><span class="line">    int c &#x3D; getState();</span><br><span class="line">    &#x2F;&#x2F; 锁处于空闲状态</span><br><span class="line">    if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            &#x2F;&#x2F; 把当前线程设置为获取了锁的线程</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 锁已经被获取, 则判断是不是当前线程之前获取的(因为是重入锁嘛)</span><br><span class="line">    else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;</span><br><span class="line">        int nextc &#x3D; c + acquires;</span><br><span class="line">        if (nextc &lt; 0) &#x2F;&#x2F; overflow, 超过整数范围了, 这重入的次数也太多了O(∩_∩)O哈哈~</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在队列中增加等待节点</span><br><span class="line">java.util.concurrent.locks.AbstractQueuedSynchronizer.addWaiter(Node) &#123;</span><br><span class="line">    Node node &#x3D; new Node(Thread.currentThread(), mode);</span><br><span class="line">    &#x2F;&#x2F; Try the fast path of enq; backup to full enq on failure</span><br><span class="line">    Node pred &#x3D; tail;</span><br><span class="line">    if (pred !&#x3D; null) &#123;</span><br><span class="line">        node.prev &#x3D; pred;</span><br><span class="line">        if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next &#x3D; node;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * </span><br><span class="line"> * Acquires in exclusive uninterruptible mode for thread already inqueue. Used by condition wait methods as well as acquire.  </span><br><span class="line"> * 以排他的不间断的方式获取已经排队的线程. 被用于 condition 的 wait 方法和 AbstractQueuedSynchronizer 的 acquire 方法.  </span><br><span class="line"> * 实际上上面的注释上让人十分困惑: 获取锁失败之后才会调用此方法, 那不应该是去阻塞当前线程吗? 而且 wait 方法中怎么会调用这样一个方法?   </span><br><span class="line"> * 我们可以这样考虑, 一个线程获取锁失败之后是不是应该不断的获取锁呢? wait 被唤醒之后是不是也应该重新获取锁呢?思考完了继续往下看   </span><br><span class="line"> * </span><br><span class="line"> * 总体来讲, acquireQueued 就是依靠前驱节点的状态来决定当前线程是否应该处于阻塞状态，</span><br><span class="line"> * 如果当前节点的前驱节点是head, 并且尝试获取锁的时候成功了，则直接返回，不需要阻塞； </span><br><span class="line"> * 如果前驱节点不是头节点或者获取锁的时候失败了，则进行判定是否需要阻塞 &#96;shouldParkAfterFailedAcquire(p, node)&#96;, 是则阻塞：</span><br><span class="line"> * 如果前驱节点处于 cancel 状态，则丢弃这些节点，重新构建队列；</span><br><span class="line"> * </span><br><span class="line"> * 如果我们用的是待超时的 tryAcquire 方法, 就不会走这个分支  </span><br><span class="line"> * 我们可以粗略的理解为, 这里就把获取锁失败的线程给 park 掉了, 官方的 DOC 写的也是看不明白. </span><br><span class="line"> *&#x2F;</span><br><span class="line">java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    boolean failed &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted &#x3D; false;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p &#x3D; node.predecessor();</span><br><span class="line">            if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                failed &#x3D; false;</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Checks and updates status for a node that failed to acquire.</span><br><span class="line"> * Returns true if thread should block. This is the main signal</span><br><span class="line"> * control in all acquire loops.  Requires that pred &#x3D;&#x3D; node.prev.</span><br><span class="line"> * </span><br><span class="line"> * 这段代码对该节点的前驱节点的状态进行判断，如果前驱节点已经处于 signal 状态，则返回true，表明当前节点可以进入阻塞状态；</span><br><span class="line"> * 否则，将前驱节点状态CAS置为signal状态，然后通过上层的 for 循环进入 parkAndCheckInterrupt 代码块park</span><br><span class="line"> * </span><br><span class="line"> * @param pred node&#39;s predecessor holding status</span><br><span class="line"> * @param node the node</span><br><span class="line"> * @return &#123;@code true&#125; if thread should block</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">    int ws &#x3D; pred.waitStatus;</span><br><span class="line">    if (ws &#x3D;&#x3D; Node.SIGNAL)</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * This node has already set status asking a release</span><br><span class="line">         * to signal it, so it can safely park.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        return true;</span><br><span class="line">    if (ws &gt; 0) &#123;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * Predecessor was cancelled. Skip over predecessors and</span><br><span class="line">         * indicate retry.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        do &#123;</span><br><span class="line">            node.prev &#x3D; pred &#x3D; pred.prev;</span><br><span class="line">        &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">        pred.next &#x3D; node;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span><br><span class="line">         * need a signal, but don&#39;t park yet.  Caller will need to</span><br><span class="line">         * retry to make sure it cannot acquire before parking.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="unlock-方法解读"><a href="#unlock-方法解读" class="headerlink" title="unlock 方法解读"></a>unlock 方法解读</h5><p>调用栈大致如下:  </p>
<ul>
<li>java.util.concurrent.locks.ReentrantLock.unlock()<ul>
<li>java.util.concurrent.locks.AbstractQueuedSynchronizer.release(int)  </li>
<li>java.util.concurrent.locks.ReentrantLock.Sync.tryRelease(int)  </li>
<li>如果 release 成功则执行 unparkSuccessor ?<br>java.util.concurrent.locks.AbstractQueuedSynchronizer.unparkSuccessor(Node)  </li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 释放锁的方法入口, 其实就是一个出队操作, tryRelease 方法修改锁的状态, 然后</span><br><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h &#x3D; head;</span><br><span class="line">        if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 修改锁的状态 </span><br><span class="line"> * 如果不是获得锁的线程调用直接抛出异常，</span><br><span class="line"> * 如果当前state-releases&#x3D;&#x3D;0也就是lock已经完全释放, 则清除资源, 返回true，</span><br><span class="line"> *&#x2F;</span><br><span class="line">Java.util.concurrent.locks.ReentrantLock.Sync.tryRelease(int releases) &#123;</span><br><span class="line">    int c &#x3D; getState() - releases;</span><br><span class="line">    if (Thread.currentThread() !&#x3D; getExclusiveOwnerThread())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    boolean free &#x3D; false;</span><br><span class="line">    if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        free &#x3D; true;</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    return free;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">  * Wakes up node&#39;s successor, if one exists.  </span><br><span class="line">  * 如果存在后继节点, 则唤醒后继节点  </span><br><span class="line">  * @param node the node</span><br><span class="line">  *&#x2F;</span><br><span class="line">java.util.concurrent.locks.AbstractQueuedSynchronizer.unparkSuccessor(Node node) &#123;</span><br><span class="line">    &#x2F;*</span><br><span class="line">      * If status is negative (i.e., possibly needing signal) try</span><br><span class="line">      * to clear in anticipation of signalling.  It is OK if this</span><br><span class="line">      * fails or if status is changed by waiting thread.</span><br><span class="line">      * 如果 status 是负数则尝试去清除被唤醒的期望. 如果失败了或者 status 被等待的线程修改了是没问题的.  </span><br><span class="line">      *&#x2F;</span><br><span class="line">    int ws &#x3D; node.waitStatus;</span><br><span class="line">    if (ws &lt; 0)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">      * Thread to unpark is held in successor, which is normally</span><br><span class="line">      * just the next node.  But if cancelled or apparently null,</span><br><span class="line">      * traverse backwards from tail to find the actual</span><br><span class="line">      * non-cancelled successor.</span><br><span class="line">      * 要被唤醒的节点在后继的节点中(持有), 通常是下一个节点.  </span><br><span class="line">      * 但是如果被取消了或者为 null,</span><br><span class="line">      * 则从 tail 反向的找没有被取消的后继节点(然后唤醒).  </span><br><span class="line">      *&#x2F;</span><br><span class="line">    Node s &#x3D; node.next;</span><br><span class="line">    if (s &#x3D;&#x3D; null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">        s &#x3D; null;</span><br><span class="line">        for (Node t &#x3D; tail; t !&#x3D; null &amp;&amp; t !&#x3D; node; t &#x3D; t.prev)</span><br><span class="line">            if (t.waitStatus &lt;&#x3D; 0)</span><br><span class="line">                s &#x3D; t;</span><br><span class="line">    &#125;</span><br><span class="line">    if (s !&#x3D; null)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="公平锁模式"><a href="#公平锁模式" class="headerlink" title="公平锁模式"></a>公平锁模式</h4><p>如果对比源码, 会发现 FairSync 和 NonfairSync 的 lock() 方法只差了两行代码, tryAcquire 和 nonfairTryAcquire 也只差了一行, 这里不再赘述.<br>实际上 java.util.concurrent.locks.ReentrantLock.tryLock() 方法只调用 nonfairTryAcquire() 方法, 不再详述. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.locks.ReentrantLock.NonfairSync.lock() &#123;</span><br><span class="line">    &#x2F;&#x2F; 首次抢锁不用排队</span><br><span class="line">    if (compareAndSetState(0, 1))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    else</span><br><span class="line">        acquire(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">java.util.concurrent.locks.ReentrantLock.FairSync.lock() &#123;</span><br><span class="line">    acquire(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.locks.ReentrantLock.tryLock()&#123;</span><br><span class="line">  return sync.nonfairTryAcquire(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">  * Performs non-fair tryLock.  tryAcquire is implemented in</span><br><span class="line">  * subclasses, but both need nonfair try for trylock method.</span><br><span class="line">  *&#x2F;</span><br><span class="line">java.util.concurrent.locks.ReentrantLock.Sync.nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current &#x3D; Thread.currentThread();</span><br><span class="line">    int c &#x3D; getState();</span><br><span class="line">    if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;</span><br><span class="line">        int nextc &#x3D; c + acquires;</span><br><span class="line">        if (nextc &lt; 0) &#x2F;&#x2F; overflow</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 下面代码可不看</span><br><span class="line"></span><br><span class="line">java.util.concurrent.locks.ReentrantLock.NonfairSync.tryAcquire(int) &#123;</span><br><span class="line">    return nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">  * Fair version of tryAcquire.  Don&#39;t grant access unless</span><br><span class="line">  * recursive call or no waiters or is first.</span><br><span class="line">  *&#x2F;</span><br><span class="line">java.util.concurrent.locks.ReentrantLock.FairSync.tryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current &#x3D; Thread.currentThread();</span><br><span class="line">    int c &#x3D; getState();</span><br><span class="line">    if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        if (!hasQueuedPredecessors() &amp;&amp;  &#x2F;&#x2F; 这里是和 nonfairTryAcquire 唯一的不同之处</span><br><span class="line">            compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;</span><br><span class="line">        int nextc &#x3D; c + acquires;</span><br><span class="line">        if (nextc &lt; 0)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p>java.util.concurrent.locks.ReentrantLock.newCondition()的作用其实是 new 了一个在AQS内部声明的ConditionObject对象.<br>ConditionObject 是AQS的内部类，可以访问AQS内部的变量（例如状态变量state）和方法。<br>每个 ConditionObject 对象都维护了一个条件队列，用来存放调 await（）方法时被阻塞的线程。注意这个条件队列和AQS队列不是一回事。<br>又是队列, 没错 Condition 其实也可以看做是一个队列.  </p>
<h3 id="wait-方法"><a href="#wait-方法" class="headerlink" title="wait 方法"></a>wait 方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public final void await() throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    &#x2F;&#x2F; 把当前线程放到等待队列中</span><br><span class="line">    Node node &#x3D; addConditionWaiter();</span><br><span class="line">    &#x2F;&#x2F; 释放已经获得的锁</span><br><span class="line">    int savedState &#x3D; fullyRelease(node);</span><br><span class="line">    int interruptMode &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; 调用 park 方法阻塞当前线程</span><br><span class="line">    while (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(this);</span><br><span class="line">        if ((interruptMode &#x3D; checkInterruptWhileWaiting(node)) !&#x3D; 0)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    if (acquireQueued(node, savedState) &amp;&amp; interruptMode !&#x3D; THROW_IE)</span><br><span class="line">        interruptMode &#x3D; REINTERRUPT;</span><br><span class="line">    if (node.nextWaiter !&#x3D; null) &#x2F;&#x2F; clean up if cancelled</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    if (interruptMode !&#x3D; 0)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AQS只提供了ConditionObject的实现，并没有提供newCondition函数，该函数用来new一个ConditionObject对象。需要由AQS的子类来提供newCondition函数。</p>
<h3 id="signalAll-方法"><a href="#signalAll-方法" class="headerlink" title="signalAll 方法"></a>signalAll 方法</h3><p>唤醒所有的等待节点, 其实源码的注释已经写得非常清楚</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject.signalAll() &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果当前线程并未获取锁, 则抛出异常</span><br><span class="line">    if (!isHeldExclusively())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    &#x2F;&#x2F; 否则唤醒所有的等待线程</span><br><span class="line">    Node first &#x3D; firstWaiter;</span><br><span class="line">    if (first !&#x3D; null)</span><br><span class="line">        doSignalAll(first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">  * Removes and transfers all nodes.</span><br><span class="line">  * @param first (non-null) the first node on condition queue</span><br><span class="line">  *&#x2F;</span><br><span class="line">java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject.doSignalAll(Node first) &#123;</span><br><span class="line">    &#x2F;&#x2F; 清空队列</span><br><span class="line">    lastWaiter &#x3D; firstWaiter &#x3D; null;</span><br><span class="line">    &#x2F;&#x2F; Transfer 所有节点(Condition 的所以节点)为 AQS 中的节点, 并挨个唤醒</span><br><span class="line">    do &#123;</span><br><span class="line">        Node next &#x3D; first.nextWaiter;</span><br><span class="line">        first.nextWaiter &#x3D; null;</span><br><span class="line">        transferForSignal(first);</span><br><span class="line">        first &#x3D; next;</span><br><span class="line">    &#125; while (first !&#x3D; null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">  * Transfers a node from a condition queue onto sync queue.</span><br><span class="line">  * Returns true if successful.</span><br><span class="line">  * @param node the node</span><br><span class="line">  * @return true if successfully transferred (else the node was</span><br><span class="line">  * cancelled before signal)</span><br><span class="line">  *&#x2F;</span><br><span class="line">java.util.concurrent.locks.AbstractQueuedSynchronizer.transferForSignal(Node node) &#123;</span><br><span class="line">    &#x2F;*</span><br><span class="line">      * If cannot change waitStatus, the node has been cancelled.</span><br><span class="line">      *&#x2F;</span><br><span class="line">    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">      * Splice onto queue and try to set waitStatus of predecessor to</span><br><span class="line">      * indicate that thread is (probably) waiting. If cancelled or</span><br><span class="line">      * attempt to set waitStatus fails, wake up to resync (in which</span><br><span class="line">      * case the waitStatus can be transiently and harmlessly wrong).</span><br><span class="line">      *&#x2F;</span><br><span class="line">    Node p &#x3D; enq(node);</span><br><span class="line">    int ws &#x3D; p.waitStatus;</span><br><span class="line">    if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结尾建议"><a href="#结尾建议" class="headerlink" title="结尾建议"></a>结尾建议</h2><p>如果能看到这里, 其实我会建议你可以去自己翻一下源码, 这个耐心完全足以看懂源码的逻辑.<br>如果你看源码感觉没有头绪,我建议你可以先(我认为你之前肯定会用 AQS 的子类, 然后)把 class 和主要的 public method 的方法(也就是你用的那一套 API)的源码注释都看一下, 基本上就能理解作者(大神)的主要思路了.  </p>
<p>当然魔鬼在于细节(大神也是, 只是一念天堂一念地狱的事), 而比较难过的是所有的技术高手往往都不能成为商业上的高手或者管理上的高手, 因为细节会最耗费精力, 诸葛亮就是事必躬亲给累死的.  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/11/concurrent/AQS-Condition/" data-id="cka2flfdc0000ucuo0vry5m3v" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java-%E5%B9%B6%E5%8F%91/" rel="tag">Java 并发</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2020/01/05/craft%20vs%20engineer/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">工匠精神 vs 工程师职责</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-%E5%B9%B6%E5%8F%91/" rel="tag">Java 并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%A2%E9%98%9F%E7%B2%BE%E7%A5%9E/" rel="tag">团队精神</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Java-%E5%B9%B6%E5%8F%91/" style="font-size: 10px;">Java 并发</a> <a href="/tags/%E5%9B%A2%E9%98%9F%E7%B2%BE%E7%A5%9E/" style="font-size: 10px;">团队精神</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/05/11/concurrent/AQS-Condition/">AQS &amp; ReentrantLock &amp; Condtion 源码解读</a>
          </li>
        
          <li>
            <a href="/2020/01/05/craft%20vs%20engineer/">工匠精神 vs 工程师职责</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>